# Fix to use tmux, rvm and zsh
if [ -x /usr/libexec/path_helper ]
then
  eval `/usr/libexec/path_helper -s`
fi

# docker autocompletion
fpath=(~/.zsh/completion $fpath)
autoload -Uz compinit && compinit -i

plugins=(docker)
export TERM=screen-256color-bce
export GOPATH=$HOME/go
export PATH="./bin/:$PATH"
export PATH="/usr/local/heroku/bin:/usr/local/bin:/usr/local/sbin:$PATH"
export PATH="$PATH:/Applications/Postgres.app/Contents/Versions/latest/bin"
export PATH="$PATH:$GOPATH/bin"
export PATH="$PATH:/usr/local/sbin/google-cloud-sdk/bin"
export JAVA_HOME="/Library/Internet Plug-Ins/JavaAppletPlugin.plugin/Contents/Home"

export ZSH=$HOME/.oh-my-zsh
[ -e $ZSH/oh-my-zsh.sh ] && source $ZSH/oh-my-zsh.sh
source ~/.prose.zsh-theme

# Use ^U to delete everything to the left
bindkey '^U' backward-kill-line

unsetopt correct_all

export EDITOR="vim"

export LANG=en_US.UTF-8
export LANGUAGE=en_US.UTF-8
export LC_ALL=en_US.UTF-8

alias brian="open -a Google\ Chrome 'https://www.google.com.br/#q=brian+thomas+storti'"
alias gbrian="open -a Google\ Chrome 'http://github.com/brianstorti'"

alias k="kubectl"
alias ez="vim ~/.zshrc"
alias v="vim ~/.vim/vimrc"
alias vi="vim"
alias reload="exec $SHELL --login"
alias e="exit"
alias :q="exit"
alias r="bin/rails"
alias t="bin/rails test"
alias va="vagrant"
alias be="bundle exec"
alias eh="sudo vim /etc/hosts"
alias l="ls -lha"
alias lr="lein run"
alias todo="vim ~/Dropbox/.todo"
alias imix="iex -S mix"
alias jpdf="/System/Library/Automator/Combine\ PDF\ Pages.action/Contents/Resources/join.py"
alias nombom='npm cache clear && bower cache clean && rm -rf node_modules bower_components && npm install && bower install'
alias remove_merged="git branch --merged | grep -v \"\*\" | grep -v master | xargs git branch -d"
alias reset_rabbit="rabbitmqctl stop_app && rabbitmqctl reset && rabbitmqctl start_app"
alias ss="spring stop"
alias h="heroku"
alias htop="sudo htop"
alias mux="tmuxinator"
alias ux="mux"

# git
alias g="git"
alias ga="g add -A"
alias gb="g branch"
alias gs="g status"
alias gl="g l -30"
alias glm="g l --author=Brian"
alias gl1="g l1"
alias gk="gk &"
alias gc="g commit --verbose"
alias gch="g checkout"
alias gp="g push -u"
alias gpp="gp && gpr"
alias gd="g diff --no-prefix"
alias gr="g reflog"
alias gdc="g diff --cached --no-prefix"
alias gt="g tag"
alias gm="g merge"
alias gpr="hub pull-request -o"

# Use fzy to select branch to checkout
function b() {
  git checkout `git branch | fzy`
}

# pg
alias pg_start="pg_ctl -D /usr/local/var/postgres -l /usr/local/var/postgres/server.log start"
alias pg_stop="pg_ctl -D /usr/local/var/postgres stop -s -m fast"

# mysql
alias mysql_start="mysql.server start"
alias mysql_stop="mysql.server stop"

# redis
alias redis_start="redis-server /usr/local/etc/redis.conf"

# memcache
alias memcache_start="/usr/local/opt/memcached/bin/memcached"

remove_all_containers() {
  docker container rm -f $(docker container ps -a -q)
}

remove_all_images() {
  docker image rm -f $(docker images -a -q)
}

man() {
  PAGER="/bin/sh -c \"col -b | vim -R -c 'set ft=man' -\"" command man $@
}

cale() {
  year=$(date | awk '{print $6}')
  cal $1 $year
}

showp() {
  lsof -i tcp:$1
}

# kills every process running on a given port
killp() {
  OLD_IFS=$IFS;

  lsof -i :$1 | grep TCP | while IFS= read -r line ; do
    kill -9 `echo $line | awk '{ print $2 }'`;
    echo `echo $line | awk '{ print $1 }'`" killed";
  done

  IFS=$OLD_IFS;
}

# finds process using `fzy` and kill it
kills() {
  kill -9 `ps axww -o pid,user,%cpu,%mem,start,time,command | fzy | sed 's/^ *//' | cut -f1 -d' '`
}

s() {
  if [ -f mix.exs ]; then
    echo "mix phoenix.server $@"
    mix phoenix.server $@
  else
    echo "rails server -b 0.0.0.0 $@"
    rails server -b 0.0.0.0 $@
  fi
}

hr() {
  line=$(printf "%-`tput cols`s" "*");
  echo ${line// /*};
}

ff() {
  find_type "f" $@
}

fl() {
  find_type "l" $@
}

fd() {
  find_type "d" $@
}

find_type() {
  search_type=$1
  name=$2
  shift 2
  find . -type $search_type -iname "*$name*" $@
}

pa() {
  ps aux | ag -i $1
}

java6() {
  export JAVA_HOME="/System/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home"
}

java7() {
  export JAVA_HOME="/Library/Java/JavaVirtualMachines/jdk1.7.0_65.jdk/Contents/Home"
}

java8() {
  export JAVA_HOME="/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home"
}

remote_debug_gradle() {
  port=${1-8080}
  export GRADLE_OPTS="-Xdebug -Xrunjdwp:transport=dt_socket,address=$port,server=y,suspend=n"
}

ip() {
  ifconfig -a | grep inet | grep broadcast | awk '{ print $2 }'
}

size() {
  du -sh $@
}

dash() {
  docset=$1
  query=$2
  open dash://$docset:$query
}

loop() {
  while [ true ]; do; $@; done;
}

replace_all() {
  source=$1
  target=$2

  ag "$source" -l | xargs sed -i '' -e "s/$source/$target/g"
}

[ -e ~/.zshrc-private ] && source ~/.zshrc-private
[ -e ~/.z.sh ] && source ~/.z.sh
[ -e ~/.fzf.zsh ] && source ~/.fzf.zsh
[ -e ~/.svnhelpers ] && source ~/.svnhelpers

eval "$(direnv hook zsh)"

. $HOME/.asdf/asdf.sh
. $HOME/.asdf/completions/asdf.bash

# The next line updates PATH for the Google Cloud SDK.
if [ -f '/usr/local/sbin/google-cloud-sdk/path.zsh.inc' ]; then source '/usr/local/sbin/google-cloud-sdk/path.zsh.inc'; fi

# The next line enables shell command completion for gcloud.
if [ -f '/usr/local/sbin/google-cloud-sdk/completion.zsh.inc' ]; then source '/usr/local/sbin/google-cloud-sdk/completion.zsh.inc'; fi
